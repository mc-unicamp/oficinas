{"version":3,"file":"connection-path-plugin.min.js","sources":["../src/path-factory.js","../src/transformers.js","../src/types.js","../src/utils.js","../src/index.js"],"sourcesContent":["import * as d3 from 'd3-shape';\n\nexport class PathFactory {\n\n    constructor(points, curve) {\n        this.points = points;\n        this.curve = curve;\n    }\n\n    line(transformer) {\n        let points = transformer(this.points);\n\n        return d3.line()\n            .x(d => d[0])\n            .y(d => d[1])\n            .curve(this.curve)\n            (points)\n    }\n\n    getData(transformer, options) {\n        return this.line(transformer(options));\n    }\n}","export default {\n    LINEAR: () => ([x1, y1, x2, y2]) => {\n        return [[x1, y1], [x2, y2]];\n    },\n    DEFAULT: ({ vertical = false, curvature = 0.4 }) => ([x1, y1, x2, y2]) => {\n        const p1 = [x1, y1];\n        const p4 = [x2, y2];\n\n        if (vertical) {\n            [x1, y1] = [y1, x1];\n            [x2, y2] = [y2, x2];\n        }\n\n        const c1 = x1 + Math.abs(x2 - x1) * curvature;\n        const c2 = x2 - Math.abs(x2 - x1) * curvature;\n        const p2 = vertical ? [y1, c1] : [c1, y1];\n        const p3 = vertical ? [y2, c2] : [c2, y2];\n\n        return [p1, p2, p3, p4];\n    }\n}","export default {\n    DEFAULT: 'DEFAULT',\n    LINEAR: 'LINEAR'\n}","export function getAngle({ x: x1, y: y1 }, { x: x2, y: y2 }) {\n    const dx = x1 - x2;\n    const dy = y1 - y2;\n\t\n    return 180 * Math.atan2(dy, dx) / Math.PI;\n}\n\nexport function getTransformAlong(path, offset, delta = 1, needRotate = true) {\n    const length = path.getTotalLength() * delta;\n    const p1 = path.getPointAtLength(length + offset);\n    const p2 = path.getPointAtLength(length);\n    const angle = 180 + (needRotate ? getAngle(p1, p2) : 0);\n\n    return `translate(${p1.x}, ${p1.y}) rotate(${angle})`;\n}","import * as d3 from 'd3-shape';\nimport { PathFactory } from './path-factory';\nimport Transformer from './transformers';\nimport Type from './types';\nimport { getTransformAlong } from './utils';\n\nfunction install(editor, { type, transformer, arrow, curve, options = {} }) {\n    type = type || Type.DEFAULT;\n    curve = curve || d3.curveBasis;\n\n    if (transformer && typeof transformer !== 'function') throw new Error('transformer property must be a function');\n    if (!Transformer[type]) throw new Error(`transformer with type ${type} doesn't exist`);\n    \n    editor.on('connectionpath', data => {\n        const { points } = data;\n        const factory = new PathFactory(points, curve);\n\n        data.d = factory.getData(transformer || Transformer[type], options);\n    });\n\n    if (arrow) {\n        editor.on('renderconnection', ({ el }) => {\n            const path = el.querySelector('path');\n            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n\n            el.querySelector('svg').appendChild(marker);\n            marker.classList.add('marker');\n            marker.setAttribute('fill', arrow.color || 'steelblue');\n            marker.setAttribute('d', arrow.marker || 'M-5,-10 L-5,10 L20,0 z');\n\n            marker.setAttribute('transform', getTransformAlong(path, -25));\n        });\n\n        editor.on('updateconnection', ({ el }) => {\n            const path = el.querySelector('path');\n            const marker = el.querySelector('.marker');\n\n            marker.setAttribute('transform', getTransformAlong(path, -25));\n        });\n    }\n}\nexport { getTransformAlong } from './utils';\n\nexport default {\n    install,\n    ...d3,\n    ...Type\n}"],"names":["PathFactory","points","curve","transformer","this","d3","x","d","y","options","line","LINEAR","DEFAULT","vertical","curvature","x1","y1","x2","y2","p1","p4","c1","Math","abs","c2","getTransformAlong","path","offset","dx","dy","delta","needRotate","length","getTotalLength","getPointAtLength","p2","angle","atan2","PI","install","editor","type","arrow","Type","Error","Transformer","on","data","factory","getData","el","querySelector","marker","document","createElementNS","appendChild","classList","add","setAttribute","color"],"mappings":";;;;;q8NAEaA,EAAb,sBAEgBC,EAAQC,8GACXD,OAASA,OACTC,MAAQA,sDAGZC,OACGF,EAASE,EAAYC,KAAKH,eAEvBI,SACFC,EAAE,SAAAC,UAAKA,EAAE,KACTC,EAAE,SAAAD,UAAKA,EAAE,KACTL,MAAME,KAAKF,MAHTG,CAIFJ,mCAGDE,EAAaM,UACVL,KAAKM,KAAKP,EAAYM,sCAlBrC,KCFe,CACXE,OAAQ,kBAAM,+BACH,CAAC,YAAU,eAEtBC,QAAS,oBAAGC,SAAAA,oBAAkBC,UAAAA,aAAY,YAAU,yBAAEC,OAAIC,OAAIC,OAAIC,OACxDC,EAAK,CAACJ,EAAIC,GACVI,EAAK,CAACH,EAAIC,MAEZL,EAAU,OACC,CAACG,EAAID,GAAfA,OAAIC,aACM,CAACE,EAAID,GAAfA,OAAIC,WAGHG,EAAKN,EAAKO,KAAKC,IAAIN,EAAKF,GAAMD,EAC9BU,EAAKP,EAAKK,KAAKC,IAAIN,EAAKF,GAAMD,QAI7B,CAACK,EAHGN,EAAW,CAACG,EAAIK,GAAM,CAACA,EAAIL,GAC3BH,EAAW,CAACK,EAAIM,GAAM,CAACA,EAAIN,GAElBE,QClBb,CACXR,QAAS,UACTD,OAAQ,UCKL,SAASc,EAAkBC,EAAMC,WAPVZ,EAAOC,EAC3BY,EACAC,EAKsCC,yDAAQ,EAAGC,6DACjDC,EAASN,EAAKO,iBAAmBH,EACjCX,EAAKO,EAAKQ,iBAAiBF,EAASL,GACpCQ,EAAKT,EAAKQ,iBAAiBF,GAC3BI,EAAQ,KAAOL,KAA0BI,EAXrBpB,KAWiBI,GAXpBb,EAAUU,IAAHR,EACxBoB,EAAKb,IAD8BT,EAEnCuB,EAAKb,IAFqCR,EAIzC,IAAMc,KAAKe,MAAMR,EAAID,GAAMN,KAAKgB,IAOc,6BAEjCnB,EAAGb,eAAMa,EAAGX,sBAAa4B,ybC+B7CG,QAtCJ,SAAiBC,SAAUC,IAAAA,KAAMtC,IAAAA,YAAauC,IAAAA,MAAOxC,IAAAA,UAAOO,QAAAA,aAAU,QAClEgC,EAAOA,GAAQE,EAAK/B,QACpBV,EAAQA,GAASG,aAEbF,GAAsC,mBAAhBA,EAA4B,MAAM,IAAIyC,MAAM,+CACjEC,EAAYJ,GAAO,MAAM,IAAIG,sCAA+BH,qBAEjED,EAAOM,GAAG,iBAAkB,SAAAC,OAChB9C,EAAW8C,EAAX9C,OACF+C,EAAU,IAAIhD,EAAYC,EAAQC,GAExC6C,EAAKxC,EAAIyC,EAAQC,QAAQ9C,GAAe0C,EAAYJ,GAAOhC,KAG3DiC,IACAF,EAAOM,GAAG,mBAAoB,gBAAGI,IAAAA,GACvBxB,EAAOwB,EAAGC,cAAc,QACxBC,EAASC,SAASC,gBAAgB,6BAA8B,QAEtEJ,EAAGC,cAAc,OAAOI,YAAYH,GACpCA,EAAOI,UAAUC,IAAI,UACrBL,EAAOM,aAAa,OAAQhB,EAAMiB,OAAS,aAC3CP,EAAOM,aAAa,IAAKhB,EAAMU,QAAU,0BAEzCA,EAAOM,aAAa,YAAajC,EAAkBC,GAAO,OAG9Dc,EAAOM,GAAG,mBAAoB,gBAAGI,IAAAA,GACvBxB,EAAOwB,EAAGC,cAAc,QACfD,EAAGC,cAAc,WAEzBO,aAAa,YAAajC,EAAkBC,GAAO,UAQ/DrB,EACAsC"}